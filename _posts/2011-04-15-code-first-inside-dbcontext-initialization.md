---
layout: default
title: "Code First: Inside DbContext Initialization"
date: 2011-04-15 20:58
day: 15th
month: April
year: 2011
author: ajcvickers
permalink: 2011/04/15/code-first-inside-dbcontext-initialization/
---

# Entity Framework 4.1
# Code First: Inside DbContext Initialization

<p>A lot of stuff happens when you use a DbContext instance for the first time. Most of the time you don't worry about this stuff, but sometimes it's useful to know what's happening under the hood. And even if it's not useful, it's hopefully interesting for its geek value alone.</p><p>Note that even though there is a lot of detail below I've actually simplified things quite a lot to avoid getting totally bogged down in code-like details. Also, I'm writing this from memory without looking at the code so forgive me if I forget something. :-)</p>  <h2>Creating a DbContext instance</h2>  <p>Not very much happens when the context instance is created. The initialization is mostly lazy so that if you never use the instance, then you pay very little cost for creating the instance.</p>  <p>It's worth noting that SaveChanges on an un-initialized context will also not cause the context to be initialized. This allows patterns that use auto-saving to be implemented very cheaply when the context has not been used and there is therefore nothing to save. </p>  <p>One thing that does happen at this stage is that the context is examined for DbSet properties and these are initialized to DbSet instances if they have public setters. This stops you getting null ref exceptions when you use the sets but still allows the sets to be defined as simple automatic properties. The delegates used to do this are cached in a mechanism similar to the one described <a href="/2011/03/29/lazycountcollection-with-better-performance/">here</a>.</p>  <h2>DbContext initialization</h2>  <p>The context is initialized when the context instance is used for the first time. “Use” means any operation on the context that requires database access or use of the underlying Entity Data Model (EDM). The initialization steps are:</p>  <ol>   <li>The context tries to find a connection or connection string:</li>    <ol>     <li>If a DbConnection was passed to the constructor, then this is used.</li>      <li>Else, if a full connection string was passed, then this is used.</li>      <li>Else, if the name of a connection string was passed and a matching connection string is found in the config file, then this is used.</li>      <li>Else, the database name is determined from the name passed to the constructor or from the context class name and the registered IConnectionFactory instance is used to create a connection by convention.</li>   </ol>    <li>The connection string is examined to see if it is an Entity Framework connection string containing details of an EDM to use or if it is a raw database connection string containing no model details.</li>    <ol>     <li>If it is an EF connection string, then an underlying ObjectContext is created in Model First/Database First mode using the EDM (the CSDL, MSL, and SSDL from the EDMX) in the connection string.</li>      <li>If it a database connection string, then the context enters Code First mode and attempts to build the Code First model as described in the next section.</li>   </ol> </ol>  <p>I made <a href="https://docs.microsoft.com/archive/blogs/adonet/using-dbcontext-in-ef-4-1-part-2-connections-and-models">a post on the EF Team blog</a> that describes some of the connection handling in more detail.</p>  <h2>Building the Code First model</h2>  <p>The EDM used by Code First for a particular context type is cached in the app-domain as an instance of DbCompiledModel. This caching ensures that the full Code First pipeline for building a model only happens once when the context is used for the first time. Therefore, when in Code First mode:</p>  <ol>   <li>DbContext checks to see if an instance of DbCompiledModel has been cached for the context type. If the model is not found in the cache, then:</li>    <ol>     <li>DbContext creates a DbModelBuilder instance.</li>      <ol>       <li>By default, the model builder convention set used is Latest. A specific convention set can be used by setting the DbModelBuilderVersionAttribute on your context.</li>     </ol>      <li>The model builder is configured with each entity type for which a DbSet property was discovered.</li>      <ol>       <li>The property names are used as the entity set names, which is useful when you're creating something like an OData feed over the model</li>     </ol>      <li>The IncludeMetadataConvention convention is applied to the builder. This will include the EdmMetadata entity in the model unless the convention is later removed.</li>      <li>The ModelContainerConvention and ModelNamespaceConvention are applied to the builder. These will use the context name as the EDM container name and the context namespace as the EDM namespace. Again, this is useful for services (like OData) that are based on the underlying EDM.</li>      <li>OnModelCreating is called to allow additional configuration of the model.</li>      <li>Build is called on the model builder.</li>      <ol>       <li>The model builder builds an internal EDM model representation based on configured types and reachability from those types and runs all the Code First conventions which further modify the model/configuration.</li>        <ol>         <li>The connection is used in this process since the SSDL part of the model depends on the target database, as represented by the provider manifest token.</li>       </ol>     </ol>      <li>Compile is called on the DbModel to create a DbCompiledModel. DbCompiledModel is currently a wrapper around the MetadataWorkspace.</li>      <ol>       <li>The model hash is also created by the call to compile.</li>     </ol>      <li>The DbCompiledModel is cached.</li>   </ol>    <li>The DbCompiledModel is used to create the underlying ObjectContext instance.</li> </ol>  <h2>Database initialization</h2>  <p>At this point we have an underlying ObjectContext, created either through Code First or using the EDM in the connection string.</p>  <p>DbContext now checks whether or not database initialization has already happened in the app-domain for the type of the derived DbContext in use and for the database connection specified. If initialization has not yet happened, then:</p>  <ol>   <li>DbContext checks whether or not an <a href="/2011/03/31/configuring-database-initializers-in-a-config-file/">IDatabaseInitializer instance has been registered</a> for the context type.</li>    <ol>     <li>If no initializer (including null) has been explicitly registered then a default initializer will be automatically registered.</li>      <ol>       <li>In Code First mode, the default initializer is CreateDatabaseIfNotExists.</li>        <li>In Database/Model First mode, the default initializer is null, meaning that no database initialization will happen by default. (Because your database almost always already exists in Database/Model First mode.)</li>     </ol>   </ol>    <li>If a non-null initializer has been found, then:</li>    <ol>     <li>A temporary ObjectContext instance is created that is backed by the same EDM as the real ObjectContext. This temp is used by the DbContext instance for all work done by the initializer and then thrown away. This ensures that work done in the initializer does not leak into the context later used by the application.</li>      <li>The initializer is run. Using the Code First default CreateDatabaseIfNotExists as an example, this does the following:</li>      <ol>       <li>A check is made to see whether or not the database already exists.</li>        <li>If the database does not exist, then it is created:</li>        <ol>         <li>This happens through the CreateDatabase functionality of the EF provider. Essentially, the SSDL of the model is the specification used to create DDL for the database schema which is then executed.</li>          <ol>           <li>If the EdmMetadata entity was included in the model, then the table for this is automatically created at the same time since it is part of the SSDL just like any other entity.</li>         </ol>          <li>If the EdmMetadata entity was included in the model, then the <a href="/2011/04/08/code-first-what-is-that-edmmetadata-table/">model hash</a> generated by Code First is written to the database by saving an instance of EdmMetadata.</li>          <li>The Seed method of the initializer is called.</li>          <li>SaveChanges is called to save changes made in the Seed method.</li>       </ol>        <li>If the database does exist, then a check is made to see if the EdmMetadata entity was included in the model and, if so, whether there is also a table with a model hash in the database.</li>        <ol>         <li>If EdmMetadata is not mapped or the database doesn't contain the table, then it is assumed that the database matches the model. This is what happens when you map to an existing database, and in this case it is up to you to ensure that the model matches the database. (Note DropCreateDatabaseIfModelChanges would throw in this situation.)</li>          <li>Otherwise, the model hash in the database is compared to the one generated by Code First. If they don't match, then an exception is thrown. (DropCreateDatabaseIfModelChanges would drop, recreate, and re-seed the database in this situation.)</li>       </ol>     </ol>      <li>The temporary ObjectContext is disposed.</li>   </ol>    <li>Control returns to whatever operation it was that caused initialization to run.</li> </ol>  <p>That's the basics. Like I mentioned above, I missed some details intentionally, and I probably missed some more by mistake. Hopefully it was somewhat useful/interesting anyway.</p>  <p>Thanks for reading!   <br />Arthur</p>  <p>P.S. There is an alternate theory of how DbContext works that suggests nuget introduces a herd of unicorns into your machine which then run on treadmills to create magic entity juice that in turn magically connects your objects to your database. I cannot comment on this theory without breaking confidentiality agreements I have signed with the unicorn king. Or something.</p>
